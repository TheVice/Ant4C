= ant4c.net.module(1)
The Vice
v2020.09.202107
:doctype: manpage
:manmanual: ANT4C.NET.MODULE
:mansource: ANT4C.NET.MODULE
:man-linkstyle: pass:[blue R < >]

== Name

ant4c.net.module - module for Ant4C program that allow to work with hosting layers of .NET - "host FXR" and "host policy", from XML script code.

[[history]]
== History

* *v2020.09.202107* +
** Added name spaces:
*** 'corehost'
*** 'corehost-context-contract'
*** 'corehost-initialize-request'
*** 'hostinterface'
*** 'hostpolicy'
*** 'net'
** With functions:
*** '<<corehost-functions,corehost::functions>>'
*** '<<corehost-is-function-exists,corehost::is-function-exists>>'
*** '<<corehost-initialize,corehost::initialize>>'
*** '<<corehost-load,corehost::load>>'
*** '<<corehost-main,corehost::main>>'
*** '<<corehost-main-with-output-buffer,corehost::main-with-output-buffer>>'
*** '<<corehost-resolve-component-dependencies,corehost::resolve-component-dependencies>>'
*** '<<corehost-set-error-writer,corehost::set-error-writer>>'
*** '<<corehost-unload,corehost::unload>>'
*** '<<corehost-context-contract-initialize,corehost-context-contract::initialize>>'
*** '<<corehost-context-contract-get-property-value,corehost-context-contract::get-property-value>>'
*** '<<corehost-context-contract-set-property-value,corehost-context-contract::set-property-value>>'
*** '<<corehost-context-contract-get-properties,corehost-context-contract::get-properties>>'
*** '<<corehost-context-contract-load-runtime,corehost-context-contract::load-runtime>>'
*** '<<corehost-context-contract-run-app,corehost-context-contract::run-app>>'
*** '<<corehost-context-contract-get-runtime-delegate,corehost-context-contract::get-runtime-delegate>>'
*** '<<corehost-initialize-request-initialize,corehost-initialize-request::initialize>>'
*** '<<corehost-initialize-request-set-config-keys,corehost-initialize-request::set-config-keys>>'
*** '<<corehost-initialize-request-set-config-values,corehost-initialize-request::set-config-values>>'
*** '<<hostinterface-initialize,hostinterface::initialize>>'
*** '<<hostinterface-set-additional-dependency-serialized,hostinterface::set-additional-dependency-serialized>>'
*** '<<hostinterface-set-application-path,hostinterface::set-application-path>>'
*** '<<hostinterface-set-config-keys,hostinterface::set-config-keys>>'
*** '<<hostinterface-set-config-values,hostinterface::set-config-values>>'
*** '<<hostinterface-set-dependency-file,hostinterface::set-dependency-file>>'
*** '<<hostinterface-set-dotnet-root,hostinterface::set-dotnet-root>>'
*** '<<hostinterface-set-file-bundle-header-offset,hostinterface::set-file-bundle-header-offset>>'
*** '<<hostinterface-set-framework-dependent,hostinterface::set-framework-dependent>>'
*** '<<hostinterface-set-framework-directories,hostinterface::set-framework-directories>>'
*** '<<hostinterface-set-framework-directory,hostinterface::set-framework-directory>>'
*** '<<hostinterface-set-framework-found-versions,hostinterface::set-framework-found-versions>>'
*** '<<hostinterface-set-framework-name,hostinterface::set-framework-name>>'
*** '<<hostinterface-set-framework-names,hostinterface::set-framework-names>>'
*** '<<hostinterface-set-framework-requested-versions,hostinterface::set-framework-requested-versions>>'
*** '<<hostinterface-set-framework-version,hostinterface::set-framework-version>>'
*** '<<hostinterface-set-host-command,hostinterface::set-host-command>>'
*** '<<hostinterface-set-host-mode,hostinterface::set-host-mode>>'
*** '<<hostinterface-set-host-path,hostinterface::set-host-path>>'
*** '<<hostinterface-set-patch-roll-forward,hostinterface::set-patch-roll-forward>>'
*** '<<hostinterface-set-paths-for-probing,hostinterface::set-paths-for-probing>>'
*** '<<hostinterface-set-prerelease-roll-forward,hostinterface::set-prerelease-roll-forward>>'
*** '<<hostinterface-set-target-framework-moniker,hostinterface::set-target-framework-moniker>>'
*** '<<hostpolicy-initialize,hostpolicy::initialize>>'
*** '<<net-result-to-string,net::result-to-string>>'

WARNING: Breaking changes - function 'result-to-string' was move from name space 'hostfxr' to the 'net', changed prefix at the type of delegate from 'host_fxr_*' to the 'net_*'.

* *v2020.09*
** Module contains name spaces:
*** 'file'
*** 'hostfxr'
*** 'nethost'
** With functions:
*** '<<file-is-assembly,file::is-assembly>>'
*** '<<hostfxr-close,hostfxr::close>>'
*** '<<hostfxr-functions,hostfxr::functions>>'
*** '<<hostfxr-get-available-sdks,hostfxr::get-available-sdks>>'
*** '<<hostfxr-get-native-search-directories,hostfxr::get-native-search-directories>>'
*** '<<hostfxr-get-runtime-delegate,hostfxr::get-runtime-delegate>>'
*** '<<hostfxr-get-runtime-properties,hostfxr::get-runtime-properties>>'
*** '<<hostfxr-get-runtime-property-value,hostfxr::get-runtime-property-value>>'
*** '<<hostfxr-initialize,hostfxr::initialize>>'
*** '<<hostfxr-initialize-for-dotnet-command-line,hostfxr::initialize-for-dotnet-command-line>>'
*** '<<hostfxr-initialize-for-runtime-config,hostfxr::initialize-for-runtime-config>>'
*** '<<hostfxr-is-function-exists,hostfxr::is-function-exists>>'
*** '<<hostfxr-main,hostfxr::main>>'
*** '<<hostfxr-main-bundle-startupinfo,hostfxr::main-bundle-startupinfo>>'
*** '<<hostfxr-main-startupinfo,hostfxr::main-startupinfo>>'
*** '<<hostfxr-resolve-sdk,hostfxr::resolve-sdk>>'
*** '<<hostfxr-resolve-sdk2,hostfxr::resolve-sdk2>>'
*** 'hostfxr::result-to-string'
*** '<<hostfxr-run-app,hostfxr::run-app>>'
*** '<<hostfxr-set-error-writer,hostfxr::set-error-writer>>'
*** '<<hostfxr-set-runtime-property-value,hostfxr::set-runtime-property-value>>'
*** '<<nethost-get-hostfxr-path,nethost::get-hostfxr-path>>'

== Installation
Place dll/so/dylib file in the folder known for ant4c application or use direct path to the binary file from the script. +
Use ant4c version that support modules.

== Module reference

=== Types structure

In this document used types *pointer* and *size_t*. +
Next structure describe they relationship with *string* type.

* string
** pointer
** size_t

All rest of types locate in same hierarchy positions like described at the documentation of Ant4C.

=== Net unit

.Functions from net unit.
|===
| Script function | Description

| <<net-result-to-string,result-to-string>> | Explain return code of functions.
|===

[[net-result-to-string]]
==== result-to-string

*string* 'net::result-to-string'(*int* code)

Return string description of return code.

===== Sample using

----
<?xml version="1.0"?>
<project>
  <choose>
    <when test="${platform::is-windows()}">
      <trycatch>
        <try>
          <loadtasks module="ant4c.net.module.dll" />
        </try>
        <catch>
           <loadtasks module="libant4c.net.module.dll" />
        </catch>
      </trycatch>
    </when>

    <when test="${platform::is-unix()}">
      <loadtasks module="libant4c.net.module.so" />
    </when>
  </choose>

  <property name="codes" value="-1 0 1 3" />
  <property name="codes"
    value="${codes} -2147024808 -2147024809 -2147450714 -2147450713" />

  <foreach item="String" in="${codes}" delim=" " property="code">
    <property name="result_in_string"
      value="${net::result-to-string(code)}" />
    <echo>net::result-to-string(${code}) -> ${result_in_string}</echo>
  </foreach>
</project>
----

Output will be:
----
net::result-to-string(-1) -> 0xffffffff -1 255
net::result-to-string(0) -> [net]::Success (0x0 0 0)
net::result-to-string(1) -> [net]::Success_HostAlreadyInitialized (0x1 1 1)
net::result-to-string(3) -> 0x3 3 3
net::result-to-string(-2147024808) -> 0x80070058 -2147024808 88
net::result-to-string(-2147024809) -> [win error]::E_INVALIDARG (0x80070057 -2147024809 87)
net::result-to-string(-2147450714) -> [net]::HostApiUnsupportedScenario (0x800080a6 -2147450714 166)
net::result-to-string(-2147450713) -> 0x800080a7 -2147450713 167
----

=== Functions for access host via FXR layer.

.Functions from host fx resolver.
|===
| Script function | Description

| <<hostfxr-functions,functions>> | Return list of functions available for the current version of host library.
| <<hostfxr-initialize,initialize>> | Initialize unit functions.
| <<hostfxr-is-function-exists,is-function-exists>> | Return *true* in case proposed function exists.
|===

[[hostfxr-functions]]
==== functions

*string* 'hostfxr::functions'() +
*string* 'hostfxr::functions'(*string* delimiter)

Return list of functions that can be used at current version of host fx resolver. +
If parameter pass - value of first one will be placed between functions. +
If no parameter pass - space symbol will be used as delimiter for names of functions.

WARNING: Function <<hostfxr-initialize,initialize>> should be call before attempt to use this one.

NOTE: This function have no forward compatibility. +
If host fx resolver publish with new functions, that not described at this help, +
new one's will not be in the return of this function.

===== Sample using

----
<?xml version="1.0"?>
<project>
  <choose>
    <when test="${platform::is-windows()}">
      <trycatch>
        <try>
          <loadtasks module="ant4c.net.module.dll" />
        </try>
        <catch>
           <loadtasks module="libant4c.net.module.dll" />
        </catch>
      </trycatch>
      <property name="path_to_hostfxr" value="hostfxr.dll" />
    </when>

    <when test="${platform::is-unix()}">
      <loadtasks module="libant4c.net.module.so" />
      <property name="path_to_hostfxr" value="libhostfxr.so" />
    </when>
  </choose>

  <property name="is_initialize" value="False" />

  <trycatch>
    <try>
      <property
        name="is_initialize"
        value="${hostfxr::initialize(path_to_hostfxr)}" />
    </try>
  </trycatch>

  <fail
    unless="${is_initialize}"
    message="Module unable to get addresses of functions from host fx resolver library (${path_to_hostfxr})" />

  <!-- A -->
  <property name="functions" value="${hostfxr::functions()}" />
  <foreach
    item="String"
    in="${functions}" delim=" " property="host_function">
    <echo>host_function -> ${host_function}</echo>
  </foreach>

  <echo />
  <!-- B -->
  <property name="functions" value="${hostfxr::functions(', ')}" />
  <echo>hostfxr::functions -> ${functions}</echo>

  <echo />
  <!-- C -->
  <property name="functions" value="${hostfxr::functions('|')}" />
  <foreach
    item="String"
    in="${functions}" delim="|" property="host_function">
    <echo>host_function -> ${host_function}</echo>
  </foreach>
</project>
----

[[hostfxr-initialize]]
==== initialize

*bool* 'hostfxr::initialize'(*file* path_to_the_host_fx_resolver)

Get addresses of functions from library of host fx resolver. +
If function return *true* other functions, that operate function name, from this name space, can be used.

===== Sample using

----
<?xml version="1.0"?>
<project>
  <choose>
    <when test="${platform::is-windows()}">
      <trycatch>
        <try>
          <loadtasks module="ant4c.net.module.dll" />
        </try>
        <catch>
          <loadtasks module="libant4c.net.module.dll" />
        </catch>
      </trycatch>
      <property
        name="fxr_folder"
        value="${environment::get-folder-path('ProgramFiles')}\dotnet\host\fxr" />
      <property name="hostfxr_file_name" value="hostfxr.dll" />
    </when>

    <when test="${platform::is-unix()}">
      <loadtasks module="libant4c.net.module.so" />
      <property
        name="fxr_folder"
        value="/usr/share/dotnet/host/fxr" />
      <property name="hostfxr_file_name" value="libhostfxr.so" />
    </when>
  </choose>

  <property
    name="paths_to_hostfxr"
    value="${directory::enumerate-file-system-entries(fxr_folder, 'file', 'true')}" />

  <foreach
    item="String"
    in="${paths_to_hostfxr}"
    property="path_to_hostfxr">

    <property name="is_initialize"
      value="${string::equal(hostfxr_file_name, string::to-lower(path::get-file-name(path_to_hostfxr)))}" />

    <property
      name="is_initialize"
      value="${hostfxr::initialize(path_to_hostfxr)}"
      if="${is_initialize}" />

    <echo>${path_to_hostfxr} -> ${is_initialize}</echo>
  </foreach>
</project>
----

[[hostfxr-is-function-exists]]
==== is-function-exists

*bool* 'hostfxr::is-function-exists'(*string* function_name)

Return *true* if name of input function available at the current version of host fx resolver.

WARNING: Function <<hostfxr-initialize,initialize>> should be call before attempt to use this one.

NOTE: This function have no forward compatibility. +
If host fx resolver publish with new functions, that not described at this help, +
new one's can not be check by this function. Function return *false* in that case.

===== Sample using

----
<?xml version="1.0"?>
<project>
  <choose>
    <when test="${platform::is-windows()}">
      <trycatch>
        <try>
          <loadtasks module="ant4c.net.module.dll" />
        </try>
        <catch>
           <loadtasks module="libant4c.net.module.dll" />
        </catch>
      </trycatch>
    </when>

    <when test="${platform::is-unix()}">
      <loadtasks module="libant4c.net.module.so" />
    </when>
  </choose>

  <fail
    unless="${property::exists('path_to_hostfxr')}"
    message="Property 'path_to_hostfxr' should be defined to use this script." />

  <property name="is_initialize" value="False" />

  <trycatch>
    <try>
      <property
        name="is_initialize"
        value="${hostfxr::initialize(path_to_hostfxr)}" />
    </try>
  </trycatch>

  <fail
    unless="${is_initialize}"
    message="Module unable to get addresses of functions from host fx resolver library (${path_to_hostfxr})" />

  <property name="functions" value="main main-bundle-startupinfo" />

  <foreach item="String" in="${functions}" delim=" " property="function">
    <property
      name="is_function_exists"
      value="${hostfxr::is-function-exists(function)}" />

    <echo>hostfxr::is-function-exists(${function}) -> ${is_function_exists}</echo>
  </foreach>
</project>
----

----
ant4c /f:sample.build -D:path_to_hostfxr="...hostfxr.dll"
ant4c /f:sample.build -D:path_to_hostfxr="...libhostfxr.so"
----

.Functions from host fx resolver, depend on version.
|===
| Script function | Host version | Description

| <<hostfxr-main,main>> ^| 1.0+ | API access to the dotnet tool.
| <<hostfxr-resolve-sdk,resolve-sdk>> ^| 2.0+ | Get path to the SDK. If host support - function <<hostfxr-resolve-sdk2,resolve-sdk2>> preferred to use.
| <<hostfxr-get-available-sdks,get-available-sdks>> .4+^.^| 2.1+ | Get available SDKs at current environment.
| <<hostfxr-get-native-search-directories,get-native-search-directories>> | Get list of directories that will be used while resolving dependency for assembly.
| <<hostfxr-main-startupinfo,main-startupinfo>> | API access to the dotnet tool. Addition parameter can be put.
| <<hostfxr-resolve-sdk2,resolve-sdk2>> | Get path to the SDK.
| <<hostfxr-close,close>> .9+^.^| 3.0+ | Close early opened context.
| <<hostfxr-get-runtime-delegate,get-runtime-delegate>> | Get pointer to the delegate of function from the assembly.
| <<hostfxr-get-runtime-properties,get-runtime-properties>> | Get properties of runtime.
| <<hostfxr-get-runtime-property-value,get-runtime-property-value>> | Get value of runtime property.
| <<hostfxr-initialize-for-dotnet-command-line,initialize-for-dotnet-command-line>> | Open context according to assembly.
| <<hostfxr-initialize-for-runtime-config,initialize-for-runtime-config>> | Open context according to json file.
| <<hostfxr-run-app,run-app>> | Run application by opened context.
| <<hostfxr-set-error-writer,set-error-writer>> | Set error writer of resolver.
| <<hostfxr-set-runtime-property-value,set-runtime-property-value>> | Set value of runtime property.
| <<hostfxr-main-bundle-startupinfo,main-bundle-startupinfo>> ^| 5.0+ | Same as <<hostfxr-main-startupinfo,main-startupinfo>> plus offset of bundle header can be provided.
|===

WARNING: Functions from this table can be used only after function <<hostfxr-initialize,initialize>> return *true*.

[[hostfxr-main]]
==== main

*int* 'hostfxr::main'(*string[]* arguments)

This function can do same things that accompanying with host fx resolver dotnet tool can.

===== Sample using

----
<?xml version="1.0"?>
<project>
  <choose>
    <when test="${platform::is-windows()}">
      <trycatch>
        <try>
          <loadtasks module="ant4c.net.module.dll" />
        </try>
        <catch>
           <loadtasks module="libant4c.net.module.dll" />
        </catch>
      </trycatch>
    </when>

    <when test="${platform::is-unix()}">
      <loadtasks module="libant4c.net.module.so" />
    </when>
  </choose>

  <property name="properties" value="path_to_hostfxr project" />

  <foreach item="String" in="${properties}" delim=" " property="property_name">
    <fail
      unless="${property::exists(property_name)}"
      message="Property '${property_name}' should be defined to use this script." />
  </foreach>

  <property name="is_initialize" value="False" />

  <trycatch>
    <try>
      <property
        name="is_initialize"
        value="${hostfxr::initialize(path_to_hostfxr)}" />
    </try>
  </trycatch>

  <fail
    unless="${is_initialize}"
    message="Module unable to get addresses of functions from host fx resolver library (${path_to_hostfxr})" />

  <property
    name="return_of_main"
    value="${hostfxr::main('', 'build', project, '/p:TargetFramework=netcoreapp2.1', '/p:Configuration=Release', '/p:OutputType=Exe')}" />

  <echo>hostfxr::main(...) -> ${return_of_main}</echo>
  <echo>hostfxr::result-to-string(hostfxr::main(...)) -> ${hostfxr::result-to-string(return_of_main)}</echo>
</project>
----

NOTE: In above example value of first parameter is empty string.

[[hostfxr-resolve-sdk]]
==== resolve-sdk

*directory* 'hostfxr::resolve-sdk'(*directory* executable_directory, *directory* working_directory)

Return path to the SDK directory. +
Description of host fx parameters can be found in the documentation of resolver. +
If path can not be located, return code in the string is returned.

NOTE: Some environment may inform in standard output that SDK not installed if this function called.
NOTE: If host support - function <<hostfxr-resolve-sdk2,resolve-sdk2>> preferred to use.

===== Sample using

----
<if test="${hostfxr::is-function-exists('resolve-sdk')}">
  <property name="resolve-sdk"
    value="${hostfxr::resolve-sdk('', '')}" />

  <echo>resolve-sdk -> ${resolve-sdk}</echo>
</if>
----

[[hostfxr-get-available-sdks]]
==== get-available-sdks

*directory*[] hostfxr::get-available-sdks() +
*directory*[] hostfxr::get-available-sdks(*directory* executable_directory)

Return paths to directories with installed SDKs.

===== Sample using

----
<if test="${hostfxr::is-function-exists('get-available-sdks')}">
  <property name="available-sdks"
    value="${hostfxr::get-available-sdks()}" />
  <!--property name="available-sdks"
    value="${hostfxr::get-available-sdks('executable_directory')}" /-->

  <foreach item="String" in="${available-sdks}" property="available-sdk">
    <echo>available-sdk -> ${available-sdk}</echo>
  </foreach>
</if>
----

[[hostfxr-get-native-search-directories]]
==== get-native-search-directories

*string* 'hostfxr::get-native-search-directories'(*string[]* arguments)

This task required .NET executable program. +
In returned string will be list of paths to folders, separated by semicolon (';') symbol on Windows and colonmark (':') on other platforms, +
that used while resolving assembly dependencies.

===== Sample using

----
<property name="path_delimiter" value=";" if="${platform::is-windows()}" />
<property name="path_delimiter" value=":" if="${platform::is-unix()}" />

<if test="${hostfxr::is-function-exists('get-native-search-directories')}">
  <property name="path_to_assembly" value="net_core_app" />
  <property
    name="directories"
    value="${hostfxr::get-native-search-directories('exec', path_to_assembly)}" />

  <foreach
    item="String" in="${directories}"
    delim="${path_delimiter}" property="directory">
    <echo>directory -> ${directory}</echo>
  </foreach>
</if>
----

[[hostfxr-main-startupinfo]]
==== main-startupinfo

*int* 'hostfxr::main-startupinfo'(*path* host_path, *path* dotnet_root, *path* application_path, *string[]* arguments)

This function can do same things that accompanying with host fx resolver dotnet tool can. +
Description of host fx parameters can be found in the documentation of resolver.

[[hostfxr-resolve-sdk2]]
==== resolve-sdk2

*string*[] 'hostfxr::resolve-sdk2'(*directory* executable_directory, *directory* working_directory, *int* key)

Get paths to the directories with SDKs. +
Function return list of strings, each one have key and path to the directory delimiter with space (' ') symbol.

----
<property name="dis_allow_pre_release" value="1" readonly="true" />

<property name="resolve-sdk2"
  value="${hostfxr::resolve-sdk2('', '', dis_allow_pre_release)}" />

<foreach
  item="String" in="${resolve-sdk2}"
  property="sdk">

  <echo if="${string::starts-with(sdk, '0 ')}">sdk -> resolved_sdk_dir</echo>
  <echo if="${string::starts-with(sdk, '1 ')}">sdk -> global_json_path</echo>

  <echo if="${math::less(2, string::get-length(sdk))}">'${string::substring(sdk, 2)}'</echo>
</foreach>
----

[[hostfxr-close]]
==== close

*int* 'hostfxr::close'(*pointer* context)

Close early opened context.

WARNING: It is caller response to put valid input data that interpret as pointer to context.

[[hostfxr-get-runtime-delegate]]
==== get-runtime-delegate

*pointer* 'hostfxr::get-runtime-delegate'(*pointer* context, *string* type_of_delegate, *file* assembly_path, *string* type_name, *string* method_name) +
*pointer* 'hostfxr::get-runtime-delegate'(*pointer* context, *int* type_of_delegate, *file* assembly_path, *string* type_name, *string* method_name) +
*pointer* 'hostfxr::get-runtime-delegate'(*pointer* context, *string* type_of_delegate, *file* assembly_path, *string* type_name, *string* method_name, *string* delegate_type_name) +
*pointer* 'hostfxr::get-runtime-delegate'(*pointer* context, *int* type_of_delegate, *file* assembly_path, *string* type_name, *string* method_name, *string* delegate_type_name)

Get pointer to the delegate of function from the assembly. In case of error function return zero start string with return code.

.Types of delegate.
|===
| net_hdt_com_activation
| net_hdt_load_in_memory_assembly
| net_hdt_winrt_activation
| net_hdt_com_register
| net_hdt_com_unregister
| net_hdt_load_assembly_and_get_function_pointer
| net_hdt_get_function_pointer
|===

Alternative direct int values of types can be used in function call.

This function can be used for checking exists of function in the assembly.

NOTE: Function <<file-is-assembly,file::is-assembly>> at second parameter can took returned pointer from this function.

WARNING: It is caller response to put valid input data that interpret as pointer to context.

===== Sample using

----
<target name="hostfxr_get-runtime-delegate">
  <!-- ... -->
  <if test="${is_context_initialized}">
    <property name="runtime_delegate"
              if="${string::equal('False', property::exists('delegate_type_name'))}"
              value="${hostfxr::get-runtime-delegate(context, type_of_delegate, assembly_path, type_name, method_name)}" />
    <property name="runtime_delegate"
              if="${property::exists('delegate_type_name')}"
              value="${hostfxr::get-runtime-delegate(context, type_of_delegate, assembly_path, type_name, method_name, delegate_type_name)}" />

    <echo>runtime_delegate -> '${runtime_delegate}' -> ${hostfxr::result-to-string(string::trim(runtime_delegate))}</echo>
  </if>
</target>

<target name="file_is-assembly">

  <property name="type_of_delegate" value="net_hdt_load_assembly_and_get_function_pointer" />

  <property name="assembly_path" value="ant4c.net.module.clr.dll" />
  <property name="type_name" value="Ant4C.Net.Module.Delegates, ant4c.net.module.clr" />
  <property name="method_name" value="FileUnit_IsAssembly" />
  <property name="delegate_type_name" value="Ant4C.Net.Module.Delegates+FileUnit_IsAssemblyDelegate, ant4c.net.module.clr" />

  <call target="hostfxr_get-runtime-delegate" />

</target>
----

[[hostfxr-get-runtime-properties]]
==== get-runtime-properties

*string* 'hostfxr::get-runtime-properties'(*pointer* context)

Get properties of runtime. In case properties can not be get - return code will be returned. +
Checking is equal ('=') symbol exists in the return can detect is properties with values returned or just return code.

WARNING: It is caller response to put valid input data that interpret as pointer to context.

[[hostfxr-get-runtime-property-value]]
==== get-runtime-property-value

*string* 'hostfxr::get-runtime-property-value'(*pointer* context, *string* property_name)

Get value of property. If property do not exists zero start string will be returned with return code.

WARNING: It is caller response to put valid input data that interpret as pointer to context.

===== Sample using

----
<property name="runtime_property" value="${hostfxr::get-runtime-property-value(context, 'property_name')}" />
<echo>runtime_property -> ${runtime_property} -> ${hostfxr::result-to-string(string::trim(runtime_property))}</echo>
----

[[hostfxr-initialize-for-dotnet-command-line]]
==== initialize-for-dotnet-command-line

*pointer* 'hostfxr::initialize-for-dotnet-command-line'(*path* path_to_assembly, *path* path_to_dot_net_root, *string[]* arguments)

Open context according to assembly. +
Return context or empty context with return code. +
Function <<hostfxr-result-to-string,result-to-string>> can be used to describe return code if it present. +
See sample using to view how to do this. +
Description of host fx parameters can be found in the documentation of resolver.

===== Sample using

----
<property
  name="context"
  readonly="true"
  value="${hostfxr::initialize-for-dotnet-command-line('', '', 'assembly', '1', '2', '3', '4', '5')}" />

<echo>hostfxr::initialize-for-dotnet-command-line -> ${context}</echo>

<property
  name="is-context-initialize"
  value="${string::equal('False', string::contains(context, ' '))}" />

<echo>is-context-initialize -> ${is-context-initialize}</echo>

<if test="${is-context-initialize}">
  <property name="close" value="${hostfxr::close(context)}" />

  <echo>hostfxr::close -> ${close} -> ${hostfxr::result-to-string(close)}</echo>
</if>

<if test="${string::equal('False', is-context-initialize)}">
  <property
    name="is-context-initialize"
    value="${string::substring(context, string::index-of(context, ' '))}" />

  <echo>is-context-initialize ->${is-context-initialize} -> ${hostfxr::result-to-string(is-context-initialize)}</echo>
</if>
----

[[hostfxr-initialize-for-runtime-config]]
==== initialize-for-runtime-config

*pointer* 'hostfxr::initialize-for-runtime-config'(*path* path_to_assembly, *path* path_to_dot_net_root, *path* path_to_json_file)

Open context according to json file.
Return context or empty context with return code. +
See sample using to view how to do this. +
Description of host fx parameters can be found in the documentation of resolver.

===== Sample using

----
<property name="tfm" value="netcoreapp3.1" readonly="true" />
<property name="framework_version" value="3.1.0" readonly="true" />

<property name="content" />
<property
  name="content"
  value="${content}{&#10;" />
<property
  name="content"
  value="${content}  &#x22;runtimeOptions&#x22;: {&#10;" />
<property
  name="content"
  value="${content}    &#x22;tfm&#x22;: &#x22;${tfm}&#x22;,&#10;" />
<property
  name="content"
  value="${content}    &#x22;rollForward&#x22;: &#x22;LatestMinor&#x22;,&#10;" />
<property
  name="content"
  value="${content}    &#x22;framework&#x22;: {&#10;" />
<property
  name="content"
  value="${content}      &#x22;name&#x22;: &#x22;Microsoft.NETCore.App&#x22;,&#10;" />
<property
  name="content"
  value="${content}      &#x22;version&#x22;: &#x22;${framework_version}&#x22; &#10;" />
<property
  name="content"
  value="${content}    }&#10;" />
<property
  name="content"
  value="${content}  }&#10;" />
<property
  name="content"
  readonly="true"
  value="${content}}" />
<echo>content -> ${content}</echo>

<property
  readonly="true"
  name="file_path"
  value="${path::get-temp-file-name()}" />
<echo>file_path -> ${file_path}</echo>

<echo message="${content}" file="${file_path}" />
<echo>file_path -> ${file_path}</echo>

<property
  name="context"
  readonly="true"
  value="${hostfxr::initialize-for-runtime-config('', '', file_path)}" />
<echo>hostfxr::initialize-for-runtime-config -> ${context}</echo>

<property
  name="is-context-initialize"
  value="${string::equal('False', string::contains(context, ' '))}" />
<echo>is-context-initialize -> ${is-context-initialize}</echo>

<if test="${is-context-initialize}">
  <property name="close" value="${hostfxr::close(context)}" />
  <echo>hostfxr::close -> ${close} -> ${hostfxr::result-to-string(close)}</echo>
</if>

<if test="${string::equal('False', is-context-initialize)}">
  <property
    name="is-context-initialize"
    value="${string::substring(context, string::index-of(context, ' '))}" />

  <echo>is-context-initialize ->${is-context-initialize} -> ${hostfxr::result-to-string(is-context-initialize)}</echo>
</if>
----

[[hostfxr-run-app]]
==== run-app

*int* 'hostfxr::run-app'(*pointer* context)

Run application by context. +
Return is returned code of application or returned code of resolver in case application can not be start.

WARNING: It is caller response to put valid input data that interpret as pointer to context.

===== Sample using

----
<if test="${is-context-initialize}">
  <property name="run-app" value="${hostfxr::run-app(context)}" />
  <echo>hostfxr::run-app -> ${run-app} -> ${hostfxr::result-to-string(run-app)}</echo>

  <property name="close" value="${hostfxr::close(context)}" />
  <echo>hostfxr::close -> ${close} -> ${hostfxr::result-to-string(close)}</echo>
</if>

<if test="${string::equal('False', is-context-initialize)}">
  <property
    name="is-context-initialize"
    value="${string::substring(context, string::index-of(context, ' '))}" />

  <echo>is-context-initialize ->${is-context-initialize} -> ${hostfxr::result-to-string(is-context-initialize)}</echo>
</if>
----

[[hostfxr-set-error-writer]]
==== set-error-writer

*pointer* 'hostfxr::set-error-writer'() +
*pointer* 'hostfxr::set-error-writer'(*file* path_to_file_for_error_writer)

Set error writer of resolver. +
First version of function will unset error writer. +
If path is empty - that call also unset error writer. +
Function return pointer to the current error writer - pointer to the function used for that purpose. +
If no writer set early - null pointer will be returned.

===== Sample using

----
<if test="${hostfxr::is-function-exists('set-error-writer')}">
  <property name="path_to_file_for_error_writer" value="${path::get-temp-file-name()}" overwrite="false" />

  <echo>path_to_file_for_error_writer -> '${path_to_file_for_error_writer}'</echo>

  <property name="error_writer" value="${hostfxr::set-error-writer(path_to_file_for_error_writer)}" />
  <echo>hostfxr::set-error-writer(${path_to_file_for_error_writer}) -> '${error_writer}'</echo>

  <!-- ... -->

  <if test="${string::equal('False', property::is-readonly('path_to_file_for_error_writer'))}">
    <property name="path_to_file_for_error_writer" />

    <property name="error_writer" value="${hostfxr::set-error-writer(path_to_file_for_error_writer)}" />
    <echo>hostfxr::set-error-writer(${path_to_file_for_error_writer}) -> '${error_writer}'</echo>
  </if>
</if>
----

[[hostfxr-set-runtime-property-value]]
==== set-runtime-property-value

*int* 'hostfxr::set-runtime-property-value'(*pointer* context, *string* property_name) +
*int* 'hostfxr::set-runtime-property-value'(*pointer* context, *string* property_name, *string* property_value)

Set value of runtime property. +
If property not exist new one will be created. +
If value not present - property will have empty value.

WARNING: It is caller response to put valid input data that interpret as pointer to context.

===== Sample using

----
<if test="${string::equal('False', property::exists('property_value'))}">
  <property name="return_of_set_runtime_property_value"
            value="${hostfxr::set-runtime-property-value(context, property_name)}" />
  <echo>hostfxr::set-runtime-property-value(${context}, ${property_name}) -> '${return_of_set_runtime_property_value}' -> ${hostfxr::result-to-string(return_of_set_runtime_property_value)}</echo>
</if>

<if test="${property::exists('property_value')}">
  <property name="return_of_set_runtime_property_value"
            value="${hostfxr::set-runtime-property-value(context, property_name, property_value)}" />
  <echo>hostfxr::set-runtime-property-value(${context}, ${property_name}, ${property_value}) -> '${return_of_set_runtime_property_value}' -> ${hostfxr::result-to-string(return_of_set_runtime_property_value)}</echo>
</if>
----

[[hostfxr-main-bundle-startupinfo]]
==== main-bundle-startupinfo

*int* 'hostfxr::main-bundle-startupinfo'(*path* host_path, *path* dotnet_root, *path* application_path, *int64* header_offset, *string[]* arguments)

This function can do same things that accompanying with host fx resolver dotnet tool can. +
Description of host fx parameters can be found in the documentation of resolver.

=== Functions for access host via host policy layer.

There are several names that allow to work with host via host policy API layer.

==== Host policy unit

Function from this unit fill list of functions to the corehost name space.

[[hostpolicy-initialize]]
===== initialize

*bool* 'hostpolicy::initialize'(*file* path_to_host_policy)

If function return *true* - functions will be added to the corehost name space.

====== Sample using

----
<fail
  unless="${property::exists('DOTNET_ROOT')}"
  message="Property 'DOTNET_ROOT' required to run this sample." />

<property name="net_core_app_with_version"
  value="${path::combine(DOTNET_ROOT, 'shared')}" />
<property name="net_core_app_with_version"
  value="${path::combine(net_core_app_with_version, 'Microsoft.NETCore.App')}" />
<property name="net_core_app_with_version"
  value="${path::combine(net_core_app_with_version, '5.0.8')}" />

<property name="host_policy_file_name"
  value="${path::combine(net_core_app_with_version, 'hostpolicy.dll')}" />
<property name="host_policy_file_name"
  unless="${file::exists(host_policy_file_name)}"
  value="${path::combine(net_core_app_with_version, 'libhostpolicy.so')}" />
<property name="host_policy_file_name"
  unless="${file::exists(host_policy_file_name)}"
  value="${path::combine(net_core_app_with_version, 'libhostpolicy.dylib')}" />

<fail unless="${file::exists(host_policy_file_name)}"
  message="File '${host_policy_file_name}' is not exists." />

<fail unless="${hostpolicy::initialize(host_policy_file_name)}"
  message="Function 'hostpolicy::initialize' is failed." />
----

==== Core host unit

.Functions from core host interface unit.
|===
| Script function | Description

| <<corehost-functions,functions>> | Return list of functions available for the current version of host library.
| <<corehost-is-function-exists,is-function-exists>> | Return *true* in case proposed function exists.
|===

[[corehost-functions]]
===== functions

*string* 'corehost::functions'() +
*string* 'corehost::functions'(*string* delimiter)

Return list of functions that can be used at current version of host policy. +
If parameter pass - value of first one will be placed between functions. +
If no parameter pass - space symbol will be used as delimiter for names of functions.

WARNING: Function <<hostpolicy-initialize,hostpolicy::initialize>> should be call before attempt to use this one.

NOTE: This function have no forward compatibility. +
If host policy publish with new functions, that not described at this help, +
new one's will not be in the return of this function.

[[corehost-is-function-exists]]
===== is-function-exists

*bool* 'corehost::is-function-exists'(*string* function_name)

Return *true* if name of input function available at the current version of host policy.

WARNING: Function <<hostpolicy-initialize,hostpolicy::initialize>> should be call before attempt to use this one.

NOTE: This function have no forward compatibility. +
If host policy publish with new functions, that not described at this help, +
new one's can not be check by this function. Function return *false* in that case.

.Functions from core host interface unit, depend on version.
|===
| Script function | Host version | Description

| <<corehost-load,load>> .3+^.^| 1.0+ | Initialize the host policy by store information that was early set by functions from <<hostinterface,host interface>> name space.
| <<corehost-main,main>> | Run application.
| <<corehost-unload,unload>> | Uninitialize the host policy.
| <<corehost-main-with-output-buffer,main-with-output-buffer>> ^.^| 2.1+ | Run application and return it output.
| <<corehost-initialize,initialize>> .3+^.^| 3.0+ | Initialize the host policy via request and options and return context contract.
| <<corehost-resolve-component-dependencies,resolve-component-dependencies>> | Resolve dependencies for specific component.
| <<corehost-set-error-writer,set-error-writer>> | Set error writer of host policy.
|===

[[corehost-load]]
===== load

*int* 'corehost::load'()

This function save information that was set early by function from <<hostinterface,host interface>> name space. +
Second call, if <<corehost-unload,unload>> was not called, will ignored data from <<hostinterface,host interface>> functions.

[[corehost-main]]
===== main

*int* 'corehost::main'(*string*[] arguments)

After loading is complete application that was set at the '<<hostinterface-set-application-path,hostinterface::set-application-path>>' function can be start with specific argument(s). +
Function return exit code of application or error code of functional that attempt to start application.

[[corehost-unload]]
===== unload

*int* 'corehost::unload'()

Unload the host policy. After this call it is able to set new data via <<hostinterface,host interface>> functions that will be read by <<corehost-load,'load'>> function.

[[corehost-main-with-output-buffer]]
===== main-with-output-buffer

*string* 'corehost::main-with-output-buffer'(*string*[] arguments)

Indentical to the <<corehost-main,'main'>> function, but output will be returned on success. +
If function is failed - error code after space symbol will be at the output.

====== Sample using

----
<property name="return_of_main" value="${corehost::main-with-output-buffer('1', '2', '3')}" />

<fail if="${string::empty(return_of_main)}"
  message="Value of property 'return_of_main' is empty." />

<property name="return_of_main_code" value="${string::trim(return_of_main)}" />

<property name="NON_SUCCESS" value="${math::less(return_of_main_code, '0')}" />
<property name="NON_SUCCESS" value="${math::greater(return_of_main_code, '2')}" unless="${NON_SUCCESS}" />

<fail if="${NON_SUCCESS}"
  message="corehost::main-with-output-buffer should return success result, instead returned ${return_of_main_code} ${net::result-to-string(return_of_main_code)}" />
----

[[corehost-initialize]]
===== initialize

*int* 'corehost::initialize'(*string* options) +
*int* 'corehost::initialize'(*int* options) +
*int* 'corehost::initialize'(*string* options, *string* not_used) +
*int* 'corehost::initialize'(*int* options, *string* not_used)

Initialize the host policy via request and options.

In order to use this function - <<corehost-context-contract-initialize,corehost-context-contract::initialize>> should be call before.
Third and fourth version should be used for first call of function. +
Before call function second time - function <<corehost-initialize-request-initialize,corehost-initialize-request::initialize>> should be call,
and first and second versions used for that purpose. +

.Options.
|===
| none
| wait_for_initialized
| get_contract
| context_contract_version_set
|===

If option can not be recognized - value will be interpreted as *int* type and second or fourth versions will be used.

If function return success code - other functions from <<corehost-context-contract,corehost-context-contract>> name space can be used.

====== Sample using

----
<property name="is_initialized" value="${corehost-context-contract::initialize()}" />
<property name="is_initialized" value="${corehost::initialize('none', '')}" />

<property name="NON_SUCCESS" value="${math::less(is_initialized, '0')}" />
<property name="NON_SUCCESS" value="${math::greater(is_initialized, '2')}" unless="${NON_SUCCESS}" />

<fail if="${NON_SUCCESS}"
      message="corehost::initialize should return success result, instead returned ${is_initialized} ${net::result-to-string(is_initialized)}" />

<property name="property_name" value="RUNTIME_IDENTIFIER" />
<property name="property_value" value="${corehost-context-contract::get-property-value(property_name)}" />
<echo>property_value -> '${property_value}' ${net::result-to-string(string::trim(property_value))}</echo>
----

[[corehost-resolve-component-dependencies]]
===== resolve-component-dependencies

*string* 'corehost::resolve-component-dependencies'(*path* assembly)

Resolve dependencies for specific component.

====== Sample using

----
<choose>
  <when test="${platform::is-unix()}">
    <property name="path_delimiter" value=":" />
  </when>
  <when test="${platform::is-windows()}">
    <property name="path_delimiter" value=";" />
  </when>
</choose>

<property name="dependencies" value="${corehost::resolve-component-dependencies(path_to_assembly)}" />
<echo>dependencies -> '${dependencies}' ${net::result-to-string(dependencies)}</echo>

<foreach item="String" in="${dependencies}" delim="${path_delimiter}" property="dependency" trim="Both">
  <fail unless="${path::is-path-rooted(dependency)}"
        message="Path should be rooted, instead it '${dependency}' (${net::result-to-string(string::trim(dependencies))})." />
  <echo>dependency -> '${dependency}'</echo>
</foreach>
----

[[corehost-set-error-writer]]
===== set-error-writer

*pointer* 'corehost::set-error-writer'() +
*pointer* 'corehost::set-error-writer'(*file* path_to_file_for_error_writer)

Set error writer of host policy. +
First version of function will unset error writer. +
If path is empty - that call also unset error writer. +
Function return pointer to the current error writer - pointer to the function used for that purpose. +
If no writer set early - null pointer will be returned.

Set error writer of host policy.

[[hostinterface]]
==== Host interface unit

Functions from this name space set data that will be used by <<corehost-load, 'corehost::load'>> function. +
Some of data will not be used by host according to it version or/and if version pass to the <<hostinterface-initialize,initialize>> function is less than recommended.

.Functions from host interface unit.
|===
| Script function | Description

| <<hostinterface-initialize,initialize>> | Set values of data to the defaults. This function should be called at least once.
| <<hostinterface-set-additional-dependency-serialized,set-additional-dependency-serialized>> | Set addition dependency serialized.
| <<hostinterface-set-application-path,set-application-path>> | Set path to the application.
| <<hostinterface-set-config-keys,set-config-keys>> | Set keys of configuration. Count should be equal to the count of values.
| <<hostinterface-set-config-values,set-config-values>> | Set values of configuration. Count should be equal to the count of keys.
| <<hostinterface-set-dependency-file,set-dependency-file>> | Set dependency file.
| <<hostinterface-set-dotnet-root,set-dotnet-root>> | Set dotnet root directory.
| <<hostinterface-set-file-bundle-header-offset,set-file-bundle-header-offset>> | Set offset of header.
| <<hostinterface-set-framework-dependent,set-framework-dependent>> | Set depend on framework.
| <<hostinterface-set-framework-directories,set-framework-directories>> | Set framework directories.
| <<hostinterface-set-framework-directory,set-framework-directory>> | Set framework directory.
| <<hostinterface-set-framework-found-versions,set-framework-found-versions>> | Set found versions.
| <<hostinterface-set-framework-name,set-framework-name>> | Set framework name.
| <<hostinterface-set-framework-names,set-framework-names>> | Set framework names.
| <<hostinterface-set-framework-requested-versions,set-framework-requested-versions>> | Set requsted framework versions.
| <<hostinterface-set-framework-version,set-framework-version>> | Set framework version.
| <<hostinterface-set-host-command,set-host-command>> | Set host command.
| <<hostinterface-set-host-mode,set-host-mode>> | Set host mode.
| <<hostinterface-set-host-path,set-host-path>> | Set path to host program.
| <<hostinterface-set-patch-roll-forward,set-patch-roll-forward>> | Set patch roll forward.
| <<hostinterface-set-paths-for-probing,set-paths-for-probing>> | Set probing paths.
| <<hostinterface-set-prerelease-roll-forward,set-prerelease-roll-forward>> | Set pre release roll forward.
| <<hostinterface-set-target-framework-moniker,set-target-framework-moniker>> | Set target framework moniker.
|===

[[hostinterface-initialize]]
===== initialize

*bool* 'hostinterface::initialize'(*size_t* version_high)

Set values of data to the defaults. At the argument - high part of version for the internal structure, it depend on host version, at the moment when this documentation was write value '369365249' should be used. Lover part of version will set at the internally.

[[hostinterface-set-additional-dependency-serialized]]
===== set-additional-dependency-serialized

*bool* 'hostinterface::set-additional-dependency-serialized'(*string* dependency)

Set addition dependency serialized. See host documentation for addition notes.

[[hostinterface-set-application-path]]
===== set-application-path

*bool* 'hostinterface::set-application-path'(*path* application)

Set path to the application.

[[hostinterface-set-config-keys]]
===== set-config-keys

*bool* 'hostinterface::set-config-keys'(*string[]* keys)

Set keys of configuration. Count should be equal to the count of values.

[[hostinterface-set-config-values]]
===== set-config-values

*bool* 'hostinterface::set-config-values'(*string[]* values)

Set values of configuration. Count should be equal to the count of keys.

====== Sample using

----
<property name="is_set"
  value="${hostinterface::set-config-keys('a', 'b', 'c', 'd', 'e')}" />
<property name="is_set"
  value="${hostinterface::set-config-values('123', '4567', '89', '0', '5')}" />
----

[[hostinterface-set-dependency-file]]
===== set-dependency-file

*bool* 'hostinterface::set-dependency-file'(*path* dependency)

Set dependency file. See host documentation for addition notes.

[[hostinterface-set-dotnet-root]]
===== set-dotnet-root

*bool* 'hostinterface::set-dotnet-root'(*path* dotnet_root)

Set dotnet root directory.

[[hostinterface-set-file-bundle-header-offset]]
===== set-file-bundle-header-offset

*bool* 'hostinterface::set-file-bundle-header-offset'(*size_t* offset)

Set offset of header. See host documentation for addition notes.

[[hostinterface-set-framework-dependent]]
===== set-framework-dependent

*bool* 'hostinterface::set-framework-dependent'(*size_t* is_depend)

Set depend on framework.

[[hostinterface-set-framework-directories]]
===== set-framework-directories

*bool* 'hostinterface::set-framework-directories'(*path[]* framework_directories)

Set framework directories.

NOTE: It is important to call both functions - 'set-framework-directories' and 'set-framework-directory' in order to be compatibility with wide list of host versions. +
Second argument of 'set-framework-directories' should be equal to the argument of 'set-framework-directory' and first be empty *string*.

[[hostinterface-set-framework-directory]]
===== set-framework-directory

*bool* 'hostinterface::set-framework-directory'(*path* framework_directory)

Set framework directory.

NOTE: It is important to call both functions - 'set-framework-directories' and 'set-framework-directory' in order to be compatibility with wide list of host versions. +
Second argument of 'set-framework-directories' should be equal to the argument of 'set-framework-directory' and first be empty *string*.

====== Sample using

----
<fail
  unless="${property::exists('DOTNET_ROOT')}"
  message="Property 'DOTNET_ROOT' required to run this sample." />

<property
  name="framework_directory"
  value="${path::combine(DOTNET_ROOT, 'shared')}" />
<property
  name="framework_directory"
  value="${path::combine(framework_directory, 'Microsoft.NETCore.App')}" />
<property
  name="framework_directory"
  value="${path::combine(framework_directory, '5.0.8')}" />

<property
  name="is_initialized"
  value="${hostinterface::initialize('369365249')}" />

<property
  name="is_initialized"
  value="${hostinterface::set-framework-directory(framework_directory)}" />
<property
  name="is_initialized"
  value="${hostinterface::set-framework-directories('', framework_directory)}" />
----

[[hostinterface-set-framework-found-versions]]
===== set-framework-found-versions

*bool* 'hostinterface::set-framework-found-versions'(*string*[] versions)

Set found versions.

NOTE: For compatibility reason first argument should be empty.

====== Sample using

----
<property
  name="is_set"
  value="${hostinterface::set-framework-found-versions('', '5.0.0')}" />
----

[[hostinterface-set-framework-name]]
===== set-framework-name

*bool* 'hostinterface::set-framework-name'(*string* name)

Set framework name.

NOTE: It is important to call both functions - 'set-framework-names' and 'set-framework-name' in order to be compatibility with wide list of host versions. +
Second argument of 'set-framework-names' should be equal to the argument of 'set-framework-name' and first be empty *string*.

[[hostinterface-set-framework-names]]
===== set-framework-names

*bool* 'hostinterface::set-framework-names'(*string*[] names)

Set framework names.

NOTE: It is important to call both functions - 'set-framework-names' and 'set-framework-name' in order to be compatibility with wide list of host versions. +
Second argument of 'set-framework-names' should be equal to the argument of 'set-framework-name' and first be empty *string*.

====== Sample using

----
<property name="is_set"
  value="${hostinterface::set-framework-name('Microsoft.NETCore.App')}" />
<property name="is_set"
  value="${hostinterface::set-framework-names('', 'Microsoft.NETCore.App')}" />
----

[[hostinterface-set-framework-requested-versions]]
===== set-framework-requested-versions

*bool* 'hostinterface::set-framework-requested-versions'(*string*[] versions)

Set requsted framework versions.

NOTE: For compatibility reason first argument should be empty.

====== Sample using

----
<property
  name="is_set"
  value="${hostinterface::set-framework-requested-versions('', '5.0.0')}" />
----

[[hostinterface-set-framework-version]]
===== set-framework-version

*bool* 'hostinterface::set-framework-version'(*string* version)

Set framework version.

[[hostinterface-set-host-command]]
===== set-host-command

*bool* 'hostinterface::set-host-command'(*string* command)

Set host command.

====== Sample using

----
<property
  name="host_command" value="get-native-search-directories" />
<property
  name="is_set" if="${property::exists('host_command')}"
  value="${hostinterface::set-host-command(host_command)}" />
----

[[hostinterface-set-host-mode]]
===== set-host-mode

*bool* 'hostinterface::set-host-mode'(*string* mode) +
*bool* 'hostinterface::set-host-mode'(*size_t* mode)

Set host mode.

First version of function can use one of the following values.

.Modes.
|===
| invalid
| muxer
| apphost
| split_fx
| libhost
|===

If mode can not be recognized - second version of function will be use and value will be interpreted as *size_t* type.

====== Sample using

----
<property
  name="is_set" value="${hostinterface::set-host-mode('libhost')}" />
----

[[hostinterface-set-host-path]]
===== set-host-path

*bool* 'hostinterface::set-host-path'(*path* host)

Set path to host program.

====== Sample using

----
<fail
  unless="${property::exists('DOTNET_ROOT')}"
  message="Property 'DOTNET_ROOT' required to run this sample." />

<property
  name="program" if="${platform::is-unix()}"
  value="${path::combine(DOTNET_ROOT, 'dotnet')}" />
<property
  name="program" if="${platform::is-windows()}"
  value="${path::combine(DOTNET_ROOT, 'dotnet.exe')}" />
<property
  name="is_initialized"
  value="${hostinterface::set-host-path(program)}" />
----

[[hostinterface-set-patch-roll-forward]]
===== set-patch-roll-forward

*bool* 'hostinterface::set-patch-roll-forward'(*size_t* patch_roll_forward)

Set patch roll forward. +
By default, after function <<hostinterface-initialize,hostinterface::initialize>> return *true*, this value is set to the '1'.

[[hostinterface-set-paths-for-probing]]
===== set-paths-for-probing

*bool* 'hostinterface::set-paths-for-probing'(*path*[] paths)

Set probing paths.

====== Sample using

----
<property name="is_initialized" if="${platform::is-windows()}"
  value="${hostinterface::set-paths-for-probing(
    path::combine(environment::get-folder-path('UserProfile'), '.nuget\packages'),
    path::combine(environment::get-folder-path('UserProfile'), '.dotnet\NuGetFallbackFolder'),
    path::combine(environment::get-folder-path('ProgramFiles'), 'dotnet\sdk\NuGetFallbackFolder'))}" />
<property name="is_initialized" unless="${platform::is-windows()}"
  value="${hostinterface::set-paths-for-probing(
    path::combine(environment::get-folder-path('UserProfile'), '.nuget/packages'),
    path::combine(environment::get-folder-path('UserProfile'), '.dotnet/NuGetFallbackFolder'))}" />
----

[[hostinterface-set-prerelease-roll-forward]]
===== set-prerelease-roll-forward

*bool* 'hostinterface::set-prerelease-roll-forward'(*size_t* roll_forward)

Set pre release roll forward.

[[hostinterface-set-target-framework-moniker]]
===== set-target-framework-moniker

*bool* 'hostinterface::set-target-framework-moniker'(*string* moniker)

Set target framework moniker.

====== Sample using

----
<property
  name="moniker"
  value="netcoreapp5.0" />
<property
  name="is_initialized"
  value="${hostinterface::set-target-framework-moniker(moniker)}" />
----

[[corehost-initialize-request]]
==== Core host initialize request unit

Functions from this name space should be used only if function <<corehost-initialize,corehost::initialize>> planned to call second time.

.Functions from core host initialize request unit.
|===
| Script function | Description

| <<corehost-initialize-request-initialize,initialize>> | Reset request to default state. This function should be called at least once.
| <<corehost-initialize-request-set-config-keys,set-config-keys>> | Set keys of configuration. Count should be equal to the count of values.
| <<corehost-initialize-request-set-config-values,set-config-values>> | Set values of configuration. Count should be equal to the count of keys.
|===

[[corehost-initialize-request-initialize]]
===== initialize

*bool* 'corehost-initialize-request::initialize'()

Reset request to default state. This function should be called at least once.

[[corehost-initialize-request-set-config-keys]]
===== set-config-keys

*bool* 'corehost-initialize-request::set-config-keys'(*string[]* keys)

Set keys of configuration. Count should be equal to the count of values.

[[corehost-initialize-request-set-config-values]]
===== set-config-values

*bool* 'corehost-initialize-request::set-config-values'(*string[]* values)

Set values of configuration. Count should be equal to the count of keys.

[[corehost-context-contract]]
==== Core host context contract unit

Functions from this name space, except 'initialize', should be used only after <<corehost-initialize,corehost::initialize>> function return success code. +
Function 'initialize' should be call before attempt to call <<corehost-initialize,corehost::initialize>> function.

Most of functions have equals at the <<hostfxr-functions, hostfxr>> name space.

.Functions from core host context contract unit.
|===
| Script function | Description

| <<corehost-context-contract-initialize,initialize>> | Reset context contract to the default state.
| <<corehost-context-contract-get-property-value,get-property-value>> | Get value of property from context contract.
| <<corehost-context-contract-set-property-value,set-property-value>> | Set value of property from context contract.
| <<corehost-context-contract-get-properties,get-properties>> | Get properties of context contract.
| <<corehost-context-contract-load-runtime,load-runtime>> | Load runtime of context contract.
| <<corehost-context-contract-run-app,run-app>> | Run application that associated with context contract.
| <<corehost-context-contract-get-runtime-delegate,get-runtime-delegate>> | Get runtime delegate from context contract.
|===

[[corehost-context-contract-initialize]]
===== initialize

*bool* 'corehost-context-contract::initialize'()

Reset context contract to the default state. +
This function should be call before <<corehost-initialize,corehost::initialize>> function.

[[corehost-context-contract-get-property-value]]
===== get-property-value

*string* 'corehost-context-contract::get-property-value'(*string* name)

Get value of requested by name property. +
If function failed - returned string with zero termination symbol and error code after.

NOTE: See also <<hostfxr-get-runtime-property-value,hostfxr::get-runtime-property-value>>.

====== Sample using

----
<property
  name="property_name" value="RUNTIME_IDENTIFIER" />
<property
  name="property_value"
  value="${corehost-context-contract::get-property-value(property_name)}" />
<echo>property_value -> '${property_value}' ${net::result-to-string(string::trim(property_value))}</echo>
----

[[corehost-context-contract-set-property-value]]
===== set-property-value

*int* 'corehost-context-contract::set-property-value'(*string* name) +
*int* 'corehost-context-contract::set-property-value'(*string* name, *string* value)

Set value of property. +
First version will remove property. +
Return result code.

NOTE: See also <<hostfxr-set-runtime-property-value,hostfxr::set-runtime-property-value>>.

[[corehost-context-contract-get-properties]]
===== get-properties

*int* 'corehost-context-contract::get-properties'()

Get properties of context contract. +
In case properties can not be get - return code will be returned. +
Checking is equal ('=') symbol exists in the return can detect is properties with values returned or just return code.

NOTE: See also <<hostfxr-get-runtime-properties,hostfxr::get-runtime-properties>>.

[[corehost-context-contract-load-runtime]]
===== load-runtime

*int* 'corehost-context-contract::load-runtime'()

Load runtime of context contract. +
Return result code.

[[corehost-context-contract-run-app]]
===== run-app

*int* 'corehost-context-contract::run-app'(*string[]* arguments)

Run application that associated with context contract. +
Return exit code of application or result code of functional that attempt to run application.

NOTE: See also <<hostfxr-run-app,hostfxr::run-app>>.

[[corehost-context-contract-get-runtime-delegate]]
===== get-runtime-delegate

*pointer* 'corehost-context-contract::get-runtime-delegate'(*string* type_of_delegate) +
*pointer* 'corehost-context-contract::get-runtime-delegate'(*int* type_of_delegate)

Get runtime delegate from context contract. +
Return pointer to delegate or space symbol with result code in case call was not success.

WARNING: Most <<hostfxr-get-runtime-delegate,delegates>> available only for Windows version of host and will made segment fault on other versions.

NOTE: Available only for compatibility. +
This function should not be used from XML script code because no other functions from this module do not use what it return at current moment. +
See also <<hostfxr-get-runtime-delegate,hostfxr::get-runtime-delegate>>.

====== Sample using

----
<property name="the_host_version" value="5.0" />
<property name="skip" value="${platform::is-unix()}" overwrite="false" />

<property name="is_initialized" value="${corehost-context-contract::get-runtime-delegate('net_hdt_com_activation')}" />
<fail unless="${string::starts-with(is_initialized, ' ')}"
      message="corehost-context-contract::get-runtime-delegate with 'net_hdt_com_activation' argument return ${is_initialized}." />

<if test="${string::equal(bool::parse('false'), skip))}">
  <property name="is_initialized" value="${corehost-context-contract::get-runtime-delegate('net_hdt_load_in_memory_assembly')}" />
  <fail if="${string::starts-with(is_initialized, ' ')}"
        message="corehost-context-contract::get-runtime-delegate with 'net_hdt_load_in_memory_assembly' argument return ${is_initialized} (${net::result-to-string(string::trim(is_initialized))})." />

  <property name="is_initialized" value="${corehost-context-contract::get-runtime-delegate('net_hdt_winrt_activation')}" />
  <fail if="${string::starts-with(is_initialized, ' ')}"
        message="corehost-context-contract::get-runtime-delegate with 'net_hdt_winrt_activation' argument return ${is_initialized} (${net::result-to-string(string::trim(is_initialized))})." />
</if>

<if test="${version::greater(the_host_version, '3.1')}">
  <property name="is_initialized" value="${corehost-context-contract::get-runtime-delegate('net_hdt_com_register')}" />
  <fail unless="${string::starts-with(is_initialized, ' ')}"
        message="corehost-context-contract::get-runtime-delegate with 'net_hdt_com_register' argument return ${is_initialized}." />
</if>

<if test="${string::equal(bool::parse('false'), skip))}">
  <property name="is_initialized" value="${corehost-context-contract::get-runtime-delegate('net_hdt_com_unregister')}" />
  <fail if="${string::starts-with(is_initialized, ' ')}"
        message="corehost-context-contract::get-runtime-delegate with 'net_hdt_com_unregister' argument return ${is_initialized} (${net::result-to-string(string::trim(is_initialized))})." />

  <property name="is_initialized" value="${corehost-context-contract::get-runtime-delegate('net_hdt_load_assembly_and_get_function_pointer')}" />
  <fail if="${string::starts-with(is_initialized, ' ')}"
        message="corehost-context-contract::get-runtime-delegate with 'net_hdt_load_assembly_and_get_function_pointer' argument return ${is_initialized} (${net::result-to-string(string::trim(is_initialized))})." />

  <property name="is_initialized" value="${corehost-context-contract::get-runtime-delegate('net_hdt_get_function_pointer')}" />
  <fail if="${string::starts-with(is_initialized, ' ')}"
        message="corehost-context-contract::get-runtime-delegate with 'net_hdt_get_function_pointer' argument return ${is_initialized} (${net::result-to-string(string::trim(is_initialized))})." />
</if>
----

=== File unit

IMPORTANT: To access function from this name space - program option *modulepriority* should be used at ant4c command arguments. Otherwise script with this function will fail according to not founded function from name space 'file'.

.Function from file unit.
|===
| Script function | Description

| <<file-is-assembly,file::is-assembly>> | Check if file at the given path is .NET assembly. If file not exists function will fail.
|===

[[file-is-assembly]]
==== is-assembly

*bool* file::is-assembly(*file* path_to_assembly) +
*bool* file::is-assembly(*file* path_to_assembly, *pointer* the_delegate) (only for hosts that have 'get-runtime-delegate' function) +
*bool* file::is-assembly(*file* path_to_assembly, *file* path_to_assembly_with_main_function) (only for hosts that do not have 'get-runtime-delegate' function)

If path point to the .NET assembly file *true* will be returned. +
If no delegate provided function will generate own based on configuration file that assumed that .NET Core 3.1 is installed (for example see configuration for <<hostfxr-initialize-for-runtime-config,initialize-for-runtime-config>> function). +
If host less than 3.1 version it will call main function of CLR side 'ant4c.net.module' library instead. +
Function <<hostfxr-get-runtime-delegate,get-runtime-delegate>> can be used to obtain 'the_delegate'.

WARNING: It is caller response to put valid input data that interpret as pointer to delegate of function.

===== Sample using

----
<property name="is-assembly" value="${file::is-assembly('ant4c.net.module.dll')}" />
<echo>is-assembly -> ${is-assembly}</echo>

<property name="is-assembly" value="${file::is-assembly('ant4c.net.module.clr.dll')}" />
<echo>is-assembly -> ${is-assembly}</echo>

<property name="is-assembly" value="${file::is-assembly('ant4c.net.module.clr.dll_')}" failonerror="false" />

<if test="${string::equal('False', hostfxr::is-function-exists('get-runtime-delegate'))}">
  <property name="is_assembly"
            value="${file::is-assembly('ant4c.net.module.clr.dll', 'ant4c.net.module.clr.dll')}" />

  <echo>is_assembly -> '${is_assembly}'</echo>
</if>

----

----
ant4c /f:sample.build -modulepriority
----

At first call of function path to non assembly file placed, second path to assembly, third to the non exists file placed and last one call at host without 'get-runtime-delegate' support.

=== Net host unit

.Function from net host unit.
|===
| Script function | Description

| <<nethost-get-hostfxr-path,nethost::get-hostfxr-path>> | Get path to host fx resolver file.
|===

[[nethost-get-hostfxr-path]]
==== get-hostfxr-path

*file* 'nethost::get-hostfxr-path'(*file* path_to_nethost) +
*file* 'nethost::get-hostfxr-path'(*file* path_to_nethost, *path* path_to_assembly) +
*file* 'nethost::get-hostfxr-path'(*file* path_to_nethost, *path* path_to_assembly, *path* path_to_dot_net_root)

Get path to host fx resolver file. +
Returned path can be used at the input of <<hostfxr-initialize,initialize>> function.

===== Sample using

----
<?xml version="1.0"?>
<project>
  <choose>
    <when test="${platform::is-windows()}">
      <trycatch>
        <try>
          <loadtasks module="ant4c.net.module.dll" />
        </try>
        <catch>
          <loadtasks module="libant4c.net.module.dll" />
        </catch>
      </trycatch>

      <property
        name="net_host_folder"
        value="${environment::get-folder-path('ProgramFiles')}\dotnet\packs" />

      <property
        name="net_host_folder"
        value="${net_host_folder}\Microsoft.NETCore.App.Host.win-x64" />

      <if test="${string::equal('False', environment::is64bit-process())}">
        <property
          name="net_host_folder"
          value="${path::combine(path::get-path-root(net_host_folder), '\Program Files\dotnet\packs')}" />

        <property
          name="net_host_folder"
          value="${net_host_folder}\Microsoft.NETCore.App.Host.win-x86" />
      </if>

      <property name="nethost_file_name" value="nethost.dll" />
    </when>

    <when test="${platform::is-unix()}">
      <loadtasks module="libant4c.net.module.so" />

      <property
        name="net_host_folder"
        value="/usr/share/dotnet/packs" />

      <property
        name="net_host_folder"
        value="${net_host_folder}/Microsoft.NETCore.App.Host.linux-x64" />

      <property name="nethost_file_name" value="libnethost.so" />
    </when>
  </choose>

  <echo>net_host_folder -> '${net_host_folder}'</echo>

  <if test="${directory::exists(net_host_folder)}">
    <property name="paths_to_nethost"
              value="${directory::enumerate-file-system-entries(net_host_folder, 'file', 'true')}" />

    <foreach item="String" in="${paths_to_nethost}" property="path_to_nethost">
      <property name="hostfxr_path" />

      <if test="${string::equal(nethost_file_name, string::to-lower(path::get-file-name(path_to_nethost)))}">
        <echo>path_to_nethost -> '${path_to_nethost}'</echo>

        <property name="hostfxr_path" value="${nethost::get-hostfxr-path(path_to_nethost)}" />

        <echo>hostfxr_path -> '${hostfxr_path}'</echo>
      </if>
    </foreach>
  </if>
</project>
----

Possible output
----
path_to_nethost -> 'C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Host.win-x64\3.1.13\runtimes\win-x64\native\nethost.dll'
hostfxr_path -> 'C:\Program Files\dotnet\host\fxr\5.0.4\hostfxr.dll'
path_to_nethost -> 'C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Host.win-x64\5.0.4\runtimes\win-x64\native\nethost.dll'
hostfxr_path -> 'C:\Program Files\dotnet\host\fxr\5.0.4\hostfxr.dll'
----

or

----
net_host_folder -> '/usr/share/dotnet/packs/Microsoft.NETCore.App.Host.linux-x64'
path_to_nethost -> '/usr/share/dotnet/packs/Microsoft.NETCore.App.Host.linux-x64/3.1.13/runtimes/linux-x64/native/libnethost.so'
hostfxr_path -> '/usr/share/dotnet/host/fxr/3.1.13/libhostfxr.so'
----

IMPORTANT: Not all versions of host fx resolver have accompanying nethost library.

== Resources

*Project web site:* https://github.com/TheVice/Ant4C

== Copying

Copyright (C) 2021 {author}. +
Free use of this software is granted under the terms of the MIT License.
